// This example is taken from http://learnopengl.com/
// http://learnopengl.com/code_viewer.php?code=getting-started/hellowindow2
// the cherno -- https://www.youtube.com/watch?v=H2E3yO0J7TM&list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2&index=3
// freecodecamp -- https://www.youtube.com/watch?v=45MIykWJ-C4&t=1237s
// The code originally used GLEW, I replaced it with Glad

//#include "config.h"
#include "Material.h"
#include "TriangleMesh.h"
#include "Shader.h"
//#include "math.h"

int main()
{
  std::cout << "Size of float: " << sizeof(float) << " bytes\n";
  std::cout << "Size of int: " << sizeof(int) << " bytes\n";
  
  std::vector<float> vertices = {
    -1.0f, -1.0f, 0.0f,         // x, y, z
    1.0f, -1.0f, 0.0f,         //colors moved to shader
    -1.0f,  1.0f, 0.0f,
    1.0f,  1.0f, 0.0f
  };

  
  setupGLFW();
  GLFWwindow *window = createWindow();
  
  // Set the clear color
  glClearColor(0.19f, 0.185f, 0.165f, 1.0f);
  
  // Setup viewport
  int width, height;
  glfwGetFramebufferSize(window, &width, &height);

  // Stuff
  GLint maxVertices, maxIndices;
  glGetIntegerv(GL_MAX_ELEMENTS_VERTICES, &maxVertices);
  glGetIntegerv(GL_MAX_ELEMENTS_INDICES, &maxIndices);
  std::cout << "Max vertices: " << maxVertices << ", Max indices: " << maxIndices << std::endl;

  std::vector<VertexAttribute> attributes = {
    VertexAttribute(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0, false)
  };
  
  VBO* vbo = new VBO(vertices, attributes);

  std::vector<VBO*> VBOs;

  VBOs.push_back(vbo);
  
  const std::vector<unsigned int> indices = {
    0, 1, 2, 1, 2, 3
  };
  
  TriangleMesh* triangle = new TriangleMesh(VBOs, indices); // it's a square!
  Material* material = new Material("../src/textures/lenna.png");
  Material* mask = new Material("../src/textures/mask.png");
  
  
  //setup shaders
  Shader shader(
		"../src/shaders/vertex.shader",
		"../src/shaders/fragment.shader"
		);
  
  //bind the shader
  glUseProgram(shader.ID); //always load shader before applying further changes
  
  //setup texture uniforms
  glUniform1i(glGetUniformLocation(shader.ID, "material"), 0);
  glUniform1i(glGetUniformLocation(shader.ID, "mask"), 1);
  
  
  //setup MVP
  glm::vec3 translation = {-0.25f * 25 * sin((float)glfwGetTime()) , 0.35f, 0.0f};
  //mat4 model = Translate(translation);
  unsigned int u_Model = glGetUniformLocation(shader.ID, "model");
  //glUniformMatrix4fv(u_Model, 1, GL_FALSE, model.entries);
  
  glm::vec3 cameraPosition = {-1.25, 0.0, 1.22};
  glm::vec3 cameraTarget = {0.0, 0.0, 0.0};
  glm::vec3 up = {0.0f, 0.0f, 1.0f};
  //mat4 view = Viewpoint(cameraPosition, cameraTarget);
  glm::mat4 view = glm::lookAt(cameraPosition, cameraTarget, up);
  unsigned int u_View  = glGetUniformLocation(shader.ID, "view");
  //glUniformMatrix4fv(u_View, 1, GL_FALSE, view.entries);
  glUniformMatrix4fv(u_View, 1, GL_FALSE, glm::value_ptr(view));
  
  // mat4 projection = Project(
  //     PI / 2.0,
  //     WIDTH / HEIGHT,
  //     0.1f,
  //     10.0f
  // );
  glm::mat4 projection = glm::perspective(
					  PI / 2.0,
					  1.0 * width / height,
					  0.1,
					  10.0
					  );
  unsigned int u_Projection = glGetUniformLocation(shader.ID, "projection");
  glUniformMatrix4fv(u_Projection, 1, GL_FALSE, glm::value_ptr(projection));
  
  
  
  //setup blending options
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  
  // uniforms
  float time=0.0f, scale=1.0f;
  GLfloat u_Time, u_Scale;
  u_Time = glGetUniformLocation(shader.ID, "time");
  u_Scale = glGetUniformLocation(shader.ID, "scale");
  
  // Game loop
  while (!glfwWindowShouldClose(window))
    {
      // Check if any events have been activated (key pressed, mouse moved etc.) and call corresponding response functions
      glfwPollEvents();
      
      
      time = glfwGetTime();
      scale = sin(time);
      
      // Render

      // Apply the shader
      shader.Activate();

      //mat4 model = TranslateRotZ(translation, .250 * glfwGetTime());
      glm::mat4 model = glm::mat4(1.0); //fill diagonal
      model = glm::translate(model, translation);
      model = glm::rotate(model, 1.70f*time, {0.5f, 0.39f, 1.0f});

      // Clear the colorbuffer       
      glClear(GL_COLOR_BUFFER_BIT);

      // Update uniforms
      glUniform1f(u_Scale, scale);
      glUniform1f(u_Time, time);
      glUniformMatrix4fv(u_Model, 1, GL_FALSE, glm::value_ptr(model));
	
      // Draw the triangle
      material->use(0);
      mask->use(1);

      triangle->draw();

      // Swap the screen buffers
      glfwSwapBuffers(window);
    }

  //cleanup
  shader.Delete();
  delete triangle;
  delete material;
  delete mask;
  delete vbo;
    
  // Terminates GLFW, clearing any resources allocated by GLFW.
  glfwTerminate();
  return 0;
}

// Is called whenever a key is pressed/released via GLFW
void key_callback(GLFWwindow *window, int key, int scancode, int action, int mode)
{
  if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
    glfwSetWindowShouldClose(window, GL_TRUE);
}

// Mouse position callback function
void mousePositionCallback(GLFWwindow* window, double xpos, double ypos) {
  std::cout << "Mouse Position: (" << xpos << ", " << ypos << ")\n";
}

// Mouse button callback function
void mouseButtonCallback(GLFWwindow* window, int button, int action, int mods) {
  if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS)
    std::cout << "Left Mouse Button Pressed\n";
  else if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_RELEASE)
    std::cout << "Left Mouse Button Released\n";
}


void setupGLFW()
{
  // Init GLFW
  glfwInit();
  // Set all the required options for GLFW
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
  glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);

  std::cout << "Starting GLFW context, OpenGL " << glfwGetVersionString() << std::endl;
}

GLFWwindow *createWindow()
{
  // Create a GLFWwindow object that we can use for GLFW's functions
  GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, "LearnOpenGL", NULL, NULL);

  if (window == NULL)
    {
      std::cout << "Failed to create GLFW window" << std::endl;
      glfwTerminate();
      return nullptr;
    }

  glfwMakeContextCurrent(window);

  // Set the required callback functions
  glfwSetKeyCallback(window, key_callback);
  // Set mouse callbacks
  glfwSetCursorPosCallback(window, mousePositionCallback);
  glfwSetMouseButtonCallback(window, mouseButtonCallback);

  // Load OpenGL functions, gladLoadGL returns the loaded version, 0 on error.
  int version = gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
  if (version == 0)
    {
      std::cout << "Failed to initialize OpenGL context" << std::endl;
      return nullptr;
    }

  // Define the viewport dimensions

  glViewport(0, 0, WIDTH, HEIGHT);
  return window;
}
