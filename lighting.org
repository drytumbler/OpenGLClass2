* Lighting math
Ah, I see the issue! If the light source is stationary but the object rotates, the lighting on the object should change realistically to reflect the object's changing orientation with respect to the stationary light. This is typically an issue of how the normals and transformations are handled in your shaders or the application of the model matrix to your normals.
Explanation:

When an object rotates, its surface normals also need to be rotated correctly to reflect how the light interacts with the surface. If the normals aren't transformed properly or if the lighting calculation uses the object space rather than world space, it can appear as if the lighting rotates with the object.

** Solution Steps:
- Ensure the normal matrix is updated correctly in your vertex shader.
- Transform normals correctly to world space or view space for accurate lighting calculations.

** Correct Handling of Normals:

Ensure that in your vertex shader, you use a normal matrix to transform the normals properly:

#+begin_src: glsl

#version 330 core

// Inputs from the vertex buffer or the vertex shader
in vec3 vertexPosition;
in vec3 vertexNormal;

// Outputs to the fragment shader
out vec3 fragNormal;
out vec3 fragPosition;

// Uniforms for the transformation matrices
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

// Normal matrix for transforming normals (inverse transpose of the model matrix)
uniform mat3 normalMatrix;

void main() {
    // Calculate the transformed position of the vertex in world space
    vec4 worldPosition = model * vec4(vertexPosition, 1.0);
    fragPosition = vec3(worldPosition);

    // Transform the normal to world space using the normal matrix
    fragNormal = normalize(normalMatrix * vertexNormal);

    // Final position of the vertex on the screen
    gl_Position = projection * view * worldPosition;
}

#+END_SRC:


** Updating the Normal Matrix in Your Code:

In your C++ code, make sure to calculate the normalMatrix as the inverse transpose of the model matrix:

#+BEGIN_SRC: cpp

glm::mat4 model = ... // Your object's model matrix
glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(model)));

// Pass this matrix to your shader
glUniformMatrix3fv(glGetUniformLocation(shader.ID, "normalMatrix"), 1, GL_FALSE, glm::value_ptr(normalMatrix));

#+END_SRC:

** Why This Works:

    The normal matrix ensures that when the model rotates or scales, the normals are transformed correctly, so the lighting calculations remain realistic. This is especially important for non-uniform scaling.
    If you apply the model matrix directly to normals without using the normal matrix (inverse transpose), the normals can become distorted, leading to incorrect lighting results.

** Final Notes:

    Ensure your fragment shader uses the transformed normals (fragNormal) for lighting calculations against the light source position.
    Verify that the light source is defined in the appropriate space (world or view space) to match the space of the transformed normals.

This approach should correct the issue where lighting appears to rotate with the object, ensuring the light interacts with the surface realistically as the object rotates.

* Calculations
Certainly! Your fragment shader is a good start for implementing basic lighting in your OpenGL application. Here are a few suggestions and explanations to enhance the lighting effect based on what you have:
** 1. Correct Light Direction Calculation

The way you're currently calculating the light direction is not correct. Instead of normalizing the light position, you need to calculate the vector from the fragment position to the light position:

#+BEGIN_SRC: glsl

vec3 toLight = normalize(lightPos - crntPos); // crntPos should be the position of the current fragment

#+END_SRC

** 2. Adding Ambient Light

You might want to include some ambient light to simulate light that exists in the scene even when a surface is not directly illuminated by a light source. Here’s how you can do it:

#+BEGIN_SRC: glsl

float ambientStrength = 0.1; // Adjust as necessary
vec3 ambient = ambientStrength * lightColor.rgb;

#+END_SRC

** 3. Improving Diffuse Calculation

The diffuse reflection model can be enhanced by adding the ambient light to the final color:

#+BEGIN_SRC: glsl

float diff = max(dot(vertexNormal, toLight), 0.0);
vec3 diffuse = diff * lightColor.rgb; // Use light color for diffuse component

#+END_SRC

** 4. Combine Components

Finally, you want to combine the ambient and diffuse components before assigning them to screenColor. Here’s how the main function can be modified:

#+BEGIN_SRC: glsl

void main() {
    vec3 baseColor = texture(sandstone, fragmentTexCoord).rgb;
    float alpha = texture(mask, fragmentTexCoord).a;

    // Calculate the light direction
    vec3 toLight = normalize(lightPos - crntPos);
    float diff = max(dot(vertexNormal, toLight), 0.0);

    // Ambient light
    float ambientStrength = 0.1; // Adjust this value as needed
    vec3 ambient = ambientStrength * lightColor.rgb;

    // Calculate the final color
    vec3 finalColor = baseColor * (ambient + diff * lightColor.rgb);
    
    // Final output color
    screenColor = vec4(finalColor, (1.0 - alpha) * (0.75 - alpha));
}

#+END_SRC

** 5. Specular Highlights (Optional)

If you want to add specular highlights to simulate shiny surfaces, you can implement Phong shading. Here's a simple approach:

    Define a view vector (direction from the fragment to the camera):

#+BEGIN_SRC:    glsl

vec3 viewDir = normalize(camPos - crntPos);

#+END_SRC

Calculate the reflection vector:

#+BEGIN_SRC: glsl

vec3 reflectDir = reflect(-toLight, vertexNormal);

#+END_SRC

Calculate the specular factor:

#+BEGIN_SRC: glsl

float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess); // shininess can be a uniform value

#+END_SRC

Add it to your final color:

#+BEGIN_SRC: glsl

    vec3 specular = spec * lightColor.rgb; // Scale by light color
    finalColor += specular; // Combine with final color

#+END_SRC
    
** Final Shader Code

Here’s a revised version of your fragment shader with basic lighting enhancements:

#+BEGIN_SRC: glsl

#version 330 core

in vec3 fragmentColor;
in vec2 fragmentTexCoord;
in vec3 vertexNormal;
in vec3 crntPos;

out vec4 screenColor;

uniform sampler2D material;
uniform sampler2D mask;
uniform sampler2D sandstone;

uniform float scale;
uniform float time;

uniform vec4 lightColor;
uniform vec3 lightPos;
uniform vec3 camPos;

void main() {
    vec3 baseColor = texture(sandstone, fragmentTexCoord).rgb;
    float alpha = texture(mask, fragmentTexCoord).a;

    // Calculate the light direction
    vec3 toLight = normalize(lightPos - crntPos);
    float diff = max(dot(vertexNormal, toLight), 0.0);

    // Ambient light
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor.rgb;

    // Final color calculation
    vec3 finalColor = baseColor * (ambient + diff * lightColor.rgb);
    
    // Final output color
    screenColor = vec4(finalColor, (1.0 - alpha) * (0.75 - alpha));
}

#+END_SRC

** Additional Tips

    Shininess: If you implement specular highlights, you may want to expose a uniform float shininess; to control the size of the highlights.
    Debugging: If the lighting does not look as expected, make sure your normals are correctly calculated and your light position is set appropriately.
    Testing Colors: Test with different ambient and diffuse strength values to find the right balance for your scene.

Feel free to modify the parameters to achieve the desired look!
